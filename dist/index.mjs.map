{"version":3,"sources":["../src/seed-generation/generate-seed.ts","../src/sequence-creation/generate-emoji-sequence.ts"],"sourcesContent":["import * as crypto from \"crypto\";\r\n\r\nfunction normalize(str:string) : string {\r\n    return (str || '').normalize('NFC');\r\n}\r\n\r\n/**\r\n * Converts an emoji sequence mnemonic into a seed string using PBKDF2 with HMAC-SHA512.\r\n *\r\n * @param {string} mnemonic - The string consisting of emojis.\r\n * @param {string} salt - The salt to use for the PBKDF2 function.\r\n * @returns {string} - The generated seed as a hexadecimal string.\r\n */\r\nexport default function emojiSequenceToSeed(mnemonic: string, salt=\"\"): string {\r\n    const mnemonicBuffer:Uint8Array = Uint8Array.from(Buffer.from(normalize(mnemonic), 'utf8'));\r\n    const Salt = crypto.createHash('sha256').update(\"emojiseed\" + salt).digest('hex');\r\n\r\n    return crypto.pbkdf2Sync(mnemonicBuffer, Salt, 2048, 64, \"sha512\").toString(\"hex\");\r\n}","import * as crypto from \"crypto\";\r\nimport emojis from \"emoji.json/emoji-compact.json\";\r\n\r\nconst EMOJI_LIST: string[] = emojis\r\n\r\nfunction generateEntropy(bits: number): Buffer {\r\n  return crypto.randomBytes(bits / 8);\r\n}\r\n\r\nfunction entropyToMnemonic(entropy: Buffer): string {\r\n  const entropyBits = Array.from(entropy)\r\n    .map((byte) => byte.toString(2).padStart(8, '0'))\r\n    .join('');\r\n\r\n  const checksumBits = crypto.createHash(\"sha256\")\r\n    .update(entropy)\r\n    .digest()\r\n    .toString(\"hex\")\r\n    .slice(0, entropy.length / 4)\r\n    .split('')\r\n    .map((hex) => parseInt(hex, 16).toString(2).padStart(4, '0'))\r\n    .join('');\r\n\r\n  const bits = entropyBits + checksumBits;\r\n  const mnemonic: string[] = [];\r\n\r\n  for (let i = 0; i < bits.length; i += 13) {\r\n    const idx = parseInt(bits.slice(i, i + 13), 2);\r\n    mnemonic.push(EMOJI_LIST[idx % EMOJI_LIST.length]); \r\n  }\r\n  return mnemonic.join(\" \");\r\n}\r\n\r\nexport default function generateSequence(bits: number = 32): string {\r\n  const entropy = generateEntropy(bits);\r\n  const mnemonic = entropyToMnemonic(entropy);\r\n  return mnemonic\r\n}"],"mappings":";AAAA,YAAY,YAAY;AAExB,SAAS,UAAU,KAAqB;AACpC,UAAQ,OAAO,IAAI,UAAU,KAAK;AACtC;AASe,SAAR,oBAAqC,UAAkB,OAAK,IAAY;AAC3E,QAAM,iBAA4B,WAAW,KAAK,OAAO,KAAK,UAAU,QAAQ,GAAG,MAAM,CAAC;AAC1F,QAAM,OAAc,kBAAW,QAAQ,EAAE,OAAO,cAAc,IAAI,EAAE,OAAO,KAAK;AAEhF,SAAc,kBAAW,gBAAgB,MAAM,MAAM,IAAI,QAAQ,EAAE,SAAS,KAAK;AACrF;;;AClBA,YAAYA,aAAY;AACxB,OAAO,YAAY;AAEnB,IAAM,aAAuB;AAE7B,SAAS,gBAAgB,MAAsB;AAC7C,SAAc,oBAAY,OAAO,CAAC;AACpC;AAEA,SAAS,kBAAkB,SAAyB;AAClD,QAAM,cAAc,MAAM,KAAK,OAAO,EACnC,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG,CAAC,EAC/C,KAAK,EAAE;AAEV,QAAM,eAAsB,mBAAW,QAAQ,EAC5C,OAAO,OAAO,EACd,OAAO,EACP,SAAS,KAAK,EACd,MAAM,GAAG,QAAQ,SAAS,CAAC,EAC3B,MAAM,EAAE,EACR,IAAI,CAAC,QAAQ,SAAS,KAAK,EAAE,EAAE,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG,CAAC,EAC3D,KAAK,EAAE;AAEV,QAAM,OAAO,cAAc;AAC3B,QAAM,WAAqB,CAAC;AAE5B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,IAAI;AACxC,UAAM,MAAM,SAAS,KAAK,MAAM,GAAG,IAAI,EAAE,GAAG,CAAC;AAC7C,aAAS,KAAK,WAAW,MAAM,WAAW,MAAM,CAAC;AAAA,EACnD;AACA,SAAO,SAAS,KAAK,GAAG;AAC1B;AAEe,SAAR,iBAAkC,OAAe,IAAY;AAClE,QAAM,UAAU,gBAAgB,IAAI;AACpC,QAAM,WAAW,kBAAkB,OAAO;AAC1C,SAAO;AACT;","names":["crypto"]}