{"version":3,"sources":["../src/index.ts","../src/seed-generation/generate-seed.ts","../src/sequence-creation/generate-emoji-sequence.ts"],"sourcesContent":["import emojiSequenceToSeed from \"./seed-generation/generate-seed\";\r\nimport generateSequence from \"./sequence-creation/generate-emoji-sequence\";\r\n\r\nexport { emojiSequenceToSeed, generateSequence };","import * as crypto from \"crypto\";\r\nimport * as argon2 from \"argon2\";\r\n\r\nfunction normalize(str: string): string {\r\n    return (str || '').normalize('NFC');\r\n}\r\n\r\n/**\r\n * Converts an emoji sequence mnemonic into a seed string using Argon2.\r\n *\r\n * @param {string} mnemonic - The string consisting of emojis.\r\n * @param {string} salt - The salt to use for the Argon2 function.\r\n * @returns {Promise<string>} - The generated seed as a hexadecimal string.\r\n */\r\nexport default async function emojiSequenceToSeed(mnemonic: string, salt = \"\"): Promise<string> {\r\n    const mnemonicBuffer: Buffer = Buffer.from(normalize(mnemonic), 'utf8');\r\n    const saltBuffer: Buffer = crypto.createHash('sha256').update(\"emojiseed\" + salt).digest();\r\n\r\n    const hash = await argon2.hash(mnemonicBuffer, {\r\n        type: argon2.argon2id,\r\n        salt: saltBuffer,\r\n        hashLength: 64,\r\n        timeCost: 3, // Number of iterations\r\n        memoryCost: 2 ** 16, // Memory usage in KiB (e.g., 64 MiB)\r\n        parallelism: 1, // Number of threads\r\n        raw: true,\r\n    });\r\n\r\n    return hash.toString(\"hex\");\r\n}","import * as crypto from \"crypto\";\r\nimport emojis from \"emoji.json/emoji-compact.json\";\r\n\r\nconst EMOJI_LIST: string[] = emojis\r\n\r\nfunction generateEntropy(bits: number): Buffer {\r\n  return crypto.randomBytes(bits / 8);\r\n}\r\n\r\nfunction entropyToMnemonic(entropy: Buffer): string {\r\n  const entropyBits = Array.from(entropy)\r\n    .map((byte) => byte.toString(2).padStart(8, '0'))\r\n    .join('');\r\n\r\n  const checksumBits = crypto.createHash(\"sha256\")\r\n    .update(entropy)\r\n    .digest()\r\n    .toString(\"hex\")\r\n    .slice(0, entropy.length / 4)\r\n    .split('')\r\n    .map((hex) => parseInt(hex, 16).toString(2).padStart(4, '0'))\r\n    .join('');\r\n\r\n  const bits = entropyBits + checksumBits;\r\n  const mnemonic: string[] = [];\r\n\r\n  for (let i = 0; i < bits.length; i += 13) {\r\n    const idx = parseInt(bits.slice(i, i + 13), 2);\r\n    mnemonic.push(EMOJI_LIST[idx % EMOJI_LIST.length]); \r\n  }\r\n  return mnemonic.join(\" \");\r\n}\r\n\r\nexport default function generateSequence(bits: number = 32): string {\r\n  const entropy = generateEntropy(bits);\r\n  const mnemonic = entropyToMnemonic(entropy);\r\n  return mnemonic\r\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,aAAwB;AACxB,aAAwB;AAExB,SAAS,UAAU,KAAqB;AACpC,UAAQ,OAAO,IAAI,UAAU,KAAK;AACtC;AASA,SAAO,oBAA2C,UAAkB,OAAO,IAAqB;AAAA;AAC5F,UAAM,iBAAyB,OAAO,KAAK,UAAU,QAAQ,GAAG,MAAM;AACtE,UAAM,aAA4B,kBAAW,QAAQ,EAAE,OAAO,cAAc,IAAI,EAAE,OAAO;AAEzF,UAAMA,QAAO,MAAa,YAAK,gBAAgB;AAAA,MAC3C,MAAa;AAAA,MACb,MAAM;AAAA,MACN,YAAY;AAAA,MACZ,UAAU;AAAA;AAAA,MACV,YAAY,KAAK;AAAA;AAAA,MACjB,aAAa;AAAA;AAAA,MACb,KAAK;AAAA,IACT,CAAC;AAED,WAAOA,MAAK,SAAS,KAAK;AAAA,EAC9B;AAAA;;;AC7BA,IAAAC,UAAwB;AACxB,2BAAmB;AAEnB,IAAM,aAAuB,qBAAAC;AAE7B,SAAS,gBAAgB,MAAsB;AAC7C,SAAc,oBAAY,OAAO,CAAC;AACpC;AAEA,SAAS,kBAAkB,SAAyB;AAClD,QAAM,cAAc,MAAM,KAAK,OAAO,EACnC,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG,CAAC,EAC/C,KAAK,EAAE;AAEV,QAAM,eAAsB,mBAAW,QAAQ,EAC5C,OAAO,OAAO,EACd,OAAO,EACP,SAAS,KAAK,EACd,MAAM,GAAG,QAAQ,SAAS,CAAC,EAC3B,MAAM,EAAE,EACR,IAAI,CAAC,QAAQ,SAAS,KAAK,EAAE,EAAE,SAAS,CAAC,EAAE,SAAS,GAAG,GAAG,CAAC,EAC3D,KAAK,EAAE;AAEV,QAAM,OAAO,cAAc;AAC3B,QAAM,WAAqB,CAAC;AAE5B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,IAAI;AACxC,UAAM,MAAM,SAAS,KAAK,MAAM,GAAG,IAAI,EAAE,GAAG,CAAC;AAC7C,aAAS,KAAK,WAAW,MAAM,WAAW,MAAM,CAAC;AAAA,EACnD;AACA,SAAO,SAAS,KAAK,GAAG;AAC1B;AAEe,SAAR,iBAAkC,OAAe,IAAY;AAClE,QAAM,UAAU,gBAAgB,IAAI;AACpC,QAAM,WAAW,kBAAkB,OAAO;AAC1C,SAAO;AACT;","names":["hash","crypto","emojis"]}